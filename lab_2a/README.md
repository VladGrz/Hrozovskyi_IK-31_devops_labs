# Lab_2a: Основи роботи з Python.

****

## Хід роботи:

1. Ознайомився з офіційною документаією _Python_.

****

2. Створив файл _task1.py_. Використовуючи команду `print` виконав наступне:
    1. Вивів вбудовані константи:
       ```python
        print("Перша константа", True)
        print("Друга константа", False)
        print("Третя константа", None)
       ```
       Результат виконання програми:
       ```
        $ python3 task2.py
        Перша константа True
        Друга константа False
        Третя константа None
       ``` 
    2. Вивів результат роботи вбудованих функцій:
       ```python
        print(f"4 в квадраті = {pow(4,2)}")
        print(f"Максимальне число серед чисел 28, 20, 45, 7: {max(28,20,45,7)}")
        x = 2
        print(f"x + 2 = {eval('x+2')}")
       ```

       Результат виконання програми:
       ```
        $ python3 task2.py
        4 в квадраті = 16
        Максимальне число серед чисел 28, 20, 45, 7: 45
        x + 2 = 4
       ```
    3. Познайомився з циклами та розгалуженнями. Написав код який демонструє роботу циклу або розгалужень:
        ```python
        for i in range(1,7):
            if i%2!=0:
                print(f"Число {i} - непарне")
            else:
                print(f"Число {i} - парне")
        z = 4
        while(z>0):
            print(f"Цикл while завершиться через: {z}")
            z-=1
       ```
       Результат виконання програми:
       ```
       $ python3 task2.py
       Число 1 - непарне
       Число 2 - парне
       Число 3 - непарне
       Число 4 - парне
       Число 5 - непарне
       Число 6 - парне
       Цикл while завершиться через: 4
       Цикл while завершиться через: 3
       Цикл while завершиться через: 2
       Цикл while завершиться через: 1
       ```
    4. Конструкція try->except->finally. Написав свій варіант коду з помилкою:
       ```python
        x = '5'
        try:
            x += 7
        except TypeError as error:
            print(f"Error: {error}, occured, please check your code")
        finally:
            print(f"x = {x}({type(x)})")
       ```
       Результат виконання програми:
        ```
       $ python3 task2.py
       Error: can only concatenate str (not "int") to str occured, please check your code
       x = 5(<class 'str'>)
       ```
    5. Ознайомився з контекст-менеджером with. Написав свій код з контекст-менеджером:
       ```python
        with open("README.md", 'r') as readme_file:
            first_str = readme_file.readline()
            print(first_str)
       ```
       Результат виконання програми:
       ```
        $ python3 task2.py
        # Lab_2a: Основи роботи з Python.
       ```
    6. Познайомився з Python lambdas. Написав свій приклад коду та як я розумію Лямбди:
       ```python
        area_of_rectangule = lambda x, y: print(f"Площа прямокутника: {x*y}")
        area_of_rectangule(2,8)
       ```
       Результат виконання програми:
       ```
       $ python3 task2.py
       Площа прямокутника: 16
       ```
       На мою думку лямбди - це такі невеличкі функції, які можна створити прямо в коді не оголошуючи окрему функцію.
       Використовують їх переважно для невеликих операцій, а також для анонімності цих функцій.

****

3. Створиву власному репозиторію таку структуру файлів:
    ```
    lab_2a/
    ├── modules/
    │   └── common.py
    ├── __init__.py
    └── __main__.py
   ```
    1. Перейшовши у папку з даними файлами запустив виконання програми командою `python3 .`  
       Результат виконання програми:
       ```
       We are in the __main__
       2021-09-26 19:39:44.083747
       linux
       test
       ```
    2. Ця програма виводить назву файлу який виконується, також дату та час виконання програми, платформу на якій
       запущено програму та повідомлення "test". Ці стрічки є результатом виконання коду що міститься в файлі \_\_main__
       .py, а саме:
         ```python
         print(f"We are in the {__name__}")
         print(common.get_current_date().now())
         print(common.get_current_platform())
         print("test")
        ```
        1. Якщо запустити програму через `python3 . -h` то в консолі з'явиться довідка по можливим командам та їх
           використанню.
              ```
              usage: . [-h] [-o OPT] [-l]
  
              Приклад передачі аргументів у Python програму.
  
              optional arguments:
              -h, --help             show this help message and exit
              -o OPT, --optional OPT 
                                     Цей параметр є вибірковим.
              -l, --logs             Якщо виконати команду з цим параметром будуть
                                     виводитись логи.
           ```
        2. Якщо передати параметри `python . -o "Цей текст також має вивестись"`, то до повідомлення яке ми отримали на
           пункті ii додасться текст "З консолі було передано аргумент
           " та та стрічка яку ми передали в командній стрічці  
           Результат виконання з параметром `-o`
              ```
               We are in the __main__
               2021-09-26 19:58:33.662993
               linux
               З консолі було передано аргумент
                ========== >> Цей текст також має вивестись << ==========
               test
              ```
        3. Ознайомився з аргументами. Першим кроком до використання `argparse` є створення об'єкта `ArgumentParser`,
           одразу можемо вказати опис програми. Цей об'єкт буде містити інформацію, необхідну для розбору командного
           рядка. Щоб додати команду використовується метод `add_argument()` в дужка потрібно вказати інформацію про
           аргументи, цей метод розповідає об'єкту `ArgumentParser` як інтерпретувати ту чи іншу команду в консолі.
           Пізніше при виклику `parse_args()` буде повернено атрибути які ми вказували при додаванні команд, і
           використовуючи ці атрибути можемо виконати ту чи іншу функцію. Так, наприклад, в програмі \_\_main__ було
           створено дві команди `-o` та `-l`, і якщо вказувалась одна з цих команд то метод `parse_args()` повертав
           атрибути команд, а атрибут команди, яку викликали буде рівен True, а потім маючи цей атрибут ми могли
           вирішити, що виводити в консоль, якщо була передана команда `-l` то `parse_args()` поверне
           атрибут `logs = True, opt=False` і рядок `if args.logs:` стане істинним в результаті чого виконається код
           всередині цього умовного оператора.  
       
        4. Познайомився з логуванням виконавши команду `python3 . --logs`. Спочатку визначаємо конфігурацію логера виконуючи метод `logging.basicConfig(level=logging.INFO, format=FORMAT)`. Аргумент `level` вказаю на рівень повідомлень, якщо надійде повідомлення нижче заданого рівня то воно буде проігнороване, якщо вище рівня то буде виведено. Параметр `format` задасть формат виводу повідомлення. Командою `logging.getLogger()` реєструємо логер. Командами `logger.info()`, `logger.warning()`, `logger.error()` можна вивести інформаційне повідомлення, повідомлення-попередження та повідомлення про помилку відповідно.  
           Результат виконання:
              ```
              2021-09-26 20:06:33,432 root INFO: Тут буде просто інформативне повідомлення
              2021-09-26 20:06:33,432 root WARNING: Це Warning повідомлення
              2021-09-26 20:06:33,432 root ERROR: Це повідомлення про помилку
              test
           ```
    3. Створив власну функцію у файлі common.py яка буде виводити всі парні числа до 100 якщо у функцію передати
       значення True і непарні якщо значення False. Викликав функцію з \_\_main__ та вивів результат. Результат
       виконання якщо передати `True`:
         ```
         python3 . -o True
         We are in the __main__
         2021-09-26 20:31:39.983591
         linux
         Парні числа:  2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100  
         test
       ```
       Результат виконання якщо передати `False`:
       ```
       python3 . -o False
       We are in the __main__
       2021-09-26 20:36:15.901466
       linux
       Непарні числа:  1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 
       test
       ```
    4. Створив функцію яка може виконуватись з помилкою. У випадку її виникнення виведіть ERROR повідомлення за
       допомогою логування (Використайте бібліотеку logging). Якщо функція відпрацювала без помилки виведіть INFO
       повідомлення.  
       Результат при помилці:
         ```
         We are in the __main__
         2021-09-26 20:53:18.854003
         linux
         Trying operation 27/0...
         2021-09-26 20:53:18,854 root ERROR: Error occured!
         test
         ```
       Результат без помилки:
         ```
         We are in the __main__
         2021-09-26 20:53:20.084966
         linux
         Trying operation 22/1...
         2021-09-26 20:53:20,085 root INFO: Error didn`t occured
         test
         ```
